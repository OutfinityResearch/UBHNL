<!doctype html>
<html lang="ro">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>UBHNL — Lexicon, CNL, DSL</title>
    <link rel="stylesheet" href="site.css" />
  </head>
  <body>
    <header>
      <h1>Lexicon, CNL și DSL</h1>
      <p>Input determinist, tipat, cu vocabular strict.</p>
    </header>
    <main>
      <div class="card">
        <div class="draft">DRAFT: sintaxă și contracte țintă; parser-ele sunt în lucru.</div>

        <div class="nav">
          <a href="index.html">Index</a>
          <a href="vision.html">Viziune</a>
          <a href="session-api.html">Session API</a>
          <a href="examples.html">Exemple</a>
          <a href="wiki/index.html">Wiki</a>
          <a href="theory/index.html">Theory</a>
          <a href="mdview.html?file=specs/DS/005-cnl-lexicon.md">DS-005</a>
          <a href="mdview.html?file=specs/DS/008-dsl.md">DS-008</a>
        </div>

        <h2>1) Lexicon (vocabularul)</h2>
        <p>
          Lexicon-ul definește tipurile (domenii finite și/sau builtins) și simbolurile permise. Regula este simplă:
          orice simbol folosit în CNL/DSL trebuie să fie declarat (altfel: eroare).
        </p>

        <h3>Format (sketch)</h3>
        <pre><code>{
  "builtins": {
    "Bool": { "kind": "builtin" },
    "Int": { "kind": "builtin" },
    "BV8": { "kind": "bitvector", "width": 8 }
  },
  "domains": {
    "Cell": ["c0", "c1"],
    "Person": ["p0"]
  },
  "constants": {
    "c0": "Cell",
    "c1": "Cell",
    "p0": "Person"
  },
  "predicates": {
    "geneA": { "arity": 1, "args": ["Cell"] },
    "proteinP": { "arity": 1, "args": ["Cell"] },
    "has_fever": { "arity": 1, "args": ["Person"] }
  },
  "aliases": {
    "protein p": "proteinP"
  }
}</code></pre>

        <h2>2) CNL (Controlled Natural Language)</h2>
        <p>
          CNL este “aproape” limbaj natural, dar controlat: cuantificatori expliciți, conectivi expliciți, scoping clar.
          Ambiguitatea este respinsă.
        </p>

        <h3>Exemple</h3>
        <pre><code>for all cell c: if geneA(c) and not inhibitor(c) then proteinP(c)
exists person p: has_fever(p) and has_flu(p)</code></pre>

        <h3>Reguli de determinism</h3>
        <ul>
          <li>Toți cuantificatorii trebuie să includă domeniu: <code>for all x in Cell: ...</code> / <code>for all cell x: ...</code>.</li>
          <li>Simbol necunoscut (predicat/constant/domeniu) = eroare.</li>
          <li>Typing strict: aritate și tipurile argumentelor trebuie să corespundă lexicon-ului.</li>
        </ul>

        <h2>3) DSL (authoring + canonical IR)</h2>
        <p>
          DSL este formatul “ingineresc”: compact, ușor de procesat, bun pentru fișiere de teorii și pentru reproducibilitate.
          Este construit pe regula <code>@ / $ / vocab</code>.
        </p>

        <h3>Regula @ / $ / vocab</h3>
        <div class="table-wrap">
          <table>
            <thead><tr><th>Formă</th><th>Semnificație</th><th>Politică</th></tr></thead>
            <tbody>
              <tr>
                <td><code>@name</code></td>
                <td>ținta statement-ului (declarație / fact statement)</td>
                <td>maxim un <code>@</code> pe linie; obligatoriu primul token</td>
              </tr>
              <tr>
                <td><code>$name</code></td>
                <td>referință la variabilă în scope (binder sau definită anterior)</td>
                <td>dacă nu e în scope → eroare</td>
              </tr>
              <tr>
                <td><code>name</code></td>
                <td>lookup în vocabular (lexicon + symbols exportate)</td>
                <td>dacă nu există → eroare</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h3>Statement-uri</h3>
        <ul>
          <li><strong>Declarație exportată</strong>: <code>@ion:Person</code> (devine simbol de vocabular)</li>
          <li><strong>Fact statement</strong>: <code>@ion has_fever</code> (assert <code>has_fever(ion)</code>)</li>
          <li><strong>Expresii logice</strong>: <code>forall $c in Cell: geneA($c) implies proteinP($c)</code> (assert expresia)</li>
          <li><strong>Query holes</strong>: <code>exists ?c in Cell: proteinP(?c)</code></li>
        </ul>

        <h3>Erori tipice (intenționate)</h3>
        <pre><code># invalid: două @ pe aceeași linie
@p0 likes @p1
# fix: p1 trebuie să fie $p1 (variabilă) sau p1 constant în vocabular

# invalid: simbol necunoscut în vocabular
@ion has_flu flu
# dacă "flu" nu e declarat ca Disease în lexicon → eroare de încărcare</code></pre>

        <h2>Link-uri (spec-uri)</h2>
        <ul>
          <li><a href="mdview.html?file=specs/DS/005-cnl-lexicon.md">DS-005 CNL + Lexicon</a></li>
          <li><a href="mdview.html?file=specs/DS/008-dsl.md">DS-008 DSL</a></li>
          <li><a href="mdview.html?file=specs/tests/cnl-cases.md">CNL cases</a></li>
          <li><a href="mdview.html?file=specs/tests/dsl-cases.md">DSL cases</a></li>
        </ul>
      </div>
    </main>
  </body>
</html>
