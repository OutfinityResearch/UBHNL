<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Theory 02: The Mathematical Soul</title>
    <link rel="stylesheet" href="../site.css" />
    <script src="../site-nav.js" defer></script>
  </head>
  <body class="with-diagram">
    <header>
      <h1>Theory 02 — The Mathematical Soul</h1>
      <p>How the simple beauty of GF(2) powers universal reasoning.</p>
    </header>
    <main>
      <div class="card">
        <div class="draft">DRAFT: narrative tutorial on Boolean foundations.</div>

        <div class="nav">
          <a href="01-orientation.html">Prev: Orientation</a>
          <a href="index.html">Theory Index</a>
          <a href="03-ubh-ir.html">Next: The UBH Kernel</a>
        </div>

        <section>
          <h2>The Use Case: The Hallway Light</h2>
          <p>
            Think of a hallway with two switches, one at each end. If you flip <em>either</em> switch, the light's state changes. This is the classic <strong>XOR</strong> (Exclusive OR) logic. 
          </p>
          <p>
            In traditional logic systems, representing this "flip-to-change" behavior can get surprisingly messy. In UBHNL, we treat XOR as a first-class citizen because it is the most natural way to describe how changes propagate through a system.
          </p>
        </section>

        <section>
          <h2>Why GF(2)? The Minimal Language of Truth</h2>
          <p>
            At its heart, everything in UBHNL is a <strong>Bit</strong>: 0 or 1. But how do we combine these bits? 
            Instead of just using traditional "AND", "OR", and "NOT", we use the mathematics of <strong>GF(2)</strong> (Galois Field of 2 elements). 
          </p>
          <p>
            In this world:
            <ul>
              <li><strong>XOR</strong> is Addition (modulo 2).</li>
              <li><strong>AND</strong> is Multiplication.</li>
            </ul>
            This might seem like a small detail, but it's a superpower. It allows us to treat logical rules as <em>Algebraic Polynomials</em>.
          </p>
        </section>

        <section>
          <h2>The ANF: Flattening Complexity</h2>
          <p>
            There is a beautiful theorem called <strong>Algebraic Normal Form (ANF)</strong>. It states that <em>any</em> logical function—no matter how complex—can be written as a unique polynomial using only XOR and AND.
          </p>
          <p>
            This is the "Secret Sauce" of our kernel. By reducing everything to polynomials, we can use 300 years of mathematical breakthroughs (like Gaussian Elimination) to solve logic puzzles that would choke a traditional "brute-force" solver.
          </p>
        </section>

        <section>
          <h2>Native XOR: Why It Matters</h2>
          <p>
            Most modern SAT solvers try to turn everything into "OR" clauses (CNF). But "OR" is terrible at representing "XOR". 
            UBHNL is a <strong>Hybrid</strong>. We have a dedicated engine for the linear math (XOR) and another for the constraints (AND). They talk to each other, sharing their discoveries in real-time.
          </p>
        </section>

        <section>
          <h2>Status & The Road Ahead</h2>
          <p>
            <strong>What works:</strong> Our kernel handles native XOR/AND with structural compression. It's fast, lean, and mathematically sound.
          </p>
          <p>
            <strong>What we're building:</strong> We are currently expanding our "Bit-Blasting" library. We want to make it easier to talk about <em>Numbers</em> (integers, floats) by automatically translating them into these elegant GF(2) polynomials.
          </p>
        </section>

        <div class="footer-links">
          <p>Deep dive into the math: <a href="../mdview.html?file=specs/DS/DS02-solver-xor.md">DS-002: Solver Interface</a>.</p>
        </div>
      </div>
    </main>
  </body>
</html>
