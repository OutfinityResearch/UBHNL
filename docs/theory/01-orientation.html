<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Theory 01: Orientation</title>
    <link rel="stylesheet" href="../site.css" />
      <script src="../site-nav.js" defer></script>
  </head>
  <body class="with-diagram">
    <header>
      <h1>Theory 01 — Orientation</h1>
      <p>What we build, the design axioms, and how the pieces fit together.</p>
    </header>
    <main>
      <div class="card">
        <div class="draft">DRAFT: tutorial chapter; specs (MD) are normative.</div>

        <div class="nav">
          <a href="index.html">Theory</a>
          <a href="../wiki/index.html">Wiki</a>
          <a href="../vision.html">Vision</a>
          <a href="02-boolean-gf2.html">Next</a>
        </div>

        <h2>UBHNL in one working sentence</h2>
        <p>
          UBHNL is a universal reasoning system where the <strong>kernel</strong> is a minimal Boolean substrate
          (<a href="../wiki/concepts/ubh.html">UBH</a>), and everything else (logics, solvers, analyzers) is implemented as
          <strong>front-ends + backends</strong> that are orchestrated, with results accepted only together with
          <a href="../wiki/concepts/certificates.html">checkable evidence</a>.
        </p>

        <h2>Why “universal” without a monolith</h2>
        <ul>
          <li>Universality is achieved via <strong>encodings</strong> (<a href="../wiki/concepts/type-lowering.html">type lowering</a>) plus <strong>orchestration</strong>, not via a single giant solver.</li>
          <li>The <a href="../wiki/decisions/minimal-kernel.html">minimal-kernel decision</a> keeps the trusted core small and preserves backend replaceability.</li>
        </ul>

        <h2>Layers (a mental model)</h2>
        <pre><code>theory files (CNL/DSL) + learn (session)
        │
        ▼
parse/type (lexicon, strict vocab) → typed semantic IR
        │
        ▼
fragment detection + goal kind
        │
        ▼
orchestrator plan DAG: lower/solve/check/refine/explain
        │
        ▼
result (SAT/UNSAT/UNKNOWN, PROVED/DISPROVED) + witness/cert + explanation</code></pre>

        <h2>The rules that remove ambiguity</h2>
        <ul>
          <li><strong>Strict vocabulary</strong>: unknown symbol ⇒ load error (<a href="../wiki/decisions/strict-vocab.html">why</a>).</li>
          <li><strong>DSL <code>@/$</code></strong>: a single <code>@</code> per line; <code>$</code> is a reference; a bare name is a vocab lookup (<a href="../wiki/decisions/dsl-at-rule.html">why</a>).</li>
          <li><strong><a href="../wiki/concepts/unknown.html">UNKNOWN</a></strong> is a valid status and is preferable to any unverifiable claim (<a href="../wiki/decisions/unknown-policy.html">why</a>).</li>
        </ul>

        <h2>What the next chapters cover</h2>
        <ol>
          <li>Boolean foundations and GF(2): why XOR/AND are a sufficient basis (<a href="../wiki/concepts/gf2.html">GF(2)</a>).</li>
          <li>UBH IR: nodes, hash-consing, and semantics (<a href="../wiki/concepts/hash-consing.html">hash-consing</a>).</li>
          <li>Solving: SAT + XOR, certificates, and explain (<a href="../wiki/concepts/sat-cdcl.html">SAT</a>, <a href="../wiki/concepts/xor-linear.html">XOR-linear</a>).</li>
          <li>Languages: lexicon/CNL/DSL and deterministic typing.</li>
          <li>Session and orchestrator: fragments/backends/tactics.</li>
        </ol>

        <h2>Normative specs</h2>
        <ul>
          <li><a href="../mdview.html?file=specs/src/system-spec.md">System Spec</a></li>
          <li><a href="../mdview.html?file=specs/UBH-SPEC.md">UBH-SPEC</a></li>
        </ul>
      </div>
    </main>
  </body>
</html>
