<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Theory 03: The UBH Kernel</title>
    <link rel="stylesheet" href="../site.css" />
    <script src="../site-nav.js" defer></script>
  </head>
  <body class="with-diagram">
    <header>
      <h1>Theory 03 — UBH: The Architecture of Structural Sharing</h1>
      <p>Optimizing reasoning through hash-consing and DAG-based representation.</p>
    </header>
    <main>
      <div class="card">
        <div class="draft">DRAFT: academic tutorial on UBH IR and hash-consing.</div>

        <div class="nav">
          <a href="02-boolean-gf2.html">Prev: Foundations</a>
          <a href="index.html">Theory Index</a>
          <a href="04-solving.html">Next: Solving</a>
        </div>

        <section>
          <h2>The Principle of Structural Compression</h2>
          <p>
            The efficiency of a universal reasoning system is heavily dependent on its ability to handle repetitive logical structures without redundant computation. In UBHNL, we address this through <strong>Structural Sharing</strong>. When large theories are loaded, identical sub-expressions are often encountered across different rules. Instead of duplicating these expressions, the system ensures that every unique logical fragment is stored exactly once, transforming the problem from a tree of symbols into a dense, compressed graph.
          </p>
        </section>

        <section>
          <h2>Hash-Consing: Canonical Deduplication</h2>
          <p>
            Our kernel, <strong>UBH</strong> (Universal Boolean Hypergraph), implements this compression through a technique called <strong>Hash-Consing</strong>. During the construction of the Boolean circuit, every new logical gate (XOR or AND) is queried against a global hash table. If a gate with the same inputs and operator already exists, the kernel returns the existing wire's unique identifier. To maximize the effectiveness of this deduplication, inputs are canonicalized—sorting by wire ID—to handle commutativity. This ensures that <code>AND(A, B)</code> and <code>AND(B, A)</code> always resolve to the same physical wire.
          </p>
        </section>

        <section>
          <h2>Wires and Nodes: The Unified IR</h2>
          <p>
            The UBH Intermediate Representation is structured as an immutable Directed Acyclic Graph (DAG) of wires. Each wire carries a unique identifier and represents a specific Boolean value within the circuit. A wire can be an atomic <strong>Constant</strong> (0 or 1), a <strong>Variable</strong> representing an external input or quantifier binder, or the output of a <strong>Gate</strong> representing an algebraic operation. Because wires are immutable, their semantic meaning is fixed upon creation, which simplifies the application of global optimizations and simplifies the verification of the resulting proofs.
          </p>
        </section>

        <section>
          <h2>Decoupling Computation from Constraint</h2>
          <p>
            A fundamental architectural distinction in UBH is the separation of <strong>Structural Definition</strong> from <strong>Logical Constraint</strong>. The DAG defines <em>how</em> values are computed (the "circuit"), while <strong>Assertions</strong> define <em>what</em> must be true (the "requirements"). For example, a theory might define a complex circuit of dependencies and then separately assert that a specific output wire must evaluate to <code>1</code>. This decoupling allows the kernel to maintain a small, auditable footprint while supporting highly complex compositions of rules and facts.
          </p>
        </section>

        <section>
          <h2>Optimization Objectives</h2>
          <p>
            While the current IR provides significant compression through hash-consing, ongoing development is focused on enhancing <strong>Local Simplifiers</strong>. By applying algebraic identities (such as idempotence and absorption) before the hash-consing stage, the system can identify semantically equivalent but syntactically different formulas. This further increases the deduplication rate and reduces the complexity of the problems presented to the back-end solvers.
          </p>
        </section>

        <div class="footer-links">
          <p>Technical Spec: <a href="../mdview.html?file=specs/DS/DS01-ir-hashcons.md">DS-001: IR and Hash-Consing</a>.</p>
        </div>
      </div>
    </main>
  </body>
</html>
