# DS-008: DSL (Intermediate Language)

## Goal
Define a deterministic, typed DSL that sits between CNL and the solver/orchestrator stack:

`CNL (user input) → DSL (canonical text IR) → typed semantic IR → fragments/backends (incl. UBH)`

The DSL is both:
1) a stable intermediate representation for compilation/debugging/auditing, and
2) a power-user authoring format for theories and queries.

## Non-Negotiable Semantics (@ / $ / vocab)
This is the core rule set you requested; it drives the entire DSL design.

### 1) `@name` — declaration/definition target
- `@name` introduces (or selects) the **definition target** of the current statement.
- A statement may contain **at most one** `@...` token, and it must be the **first** term on the line.
- `@` is never used for references.

### 2) `$name` — variable reference
- `$name` references a symbol previously introduced by `@name` (or by a quantifier binder).
- Using `$name` when `name` is not in scope is a **load error**.

### 3) bare `name` — vocabulary lookup
- A bare identifier is looked up in the **vocabulary** (lexicon + any explicitly exported symbols).
- If the symbol is unknown, it is a **load error** (no silent creation).

This makes theory files reproducible and prevents “typo turns into new symbol”.

## Statement Forms
### A) Declarations (Leaf Nodes)
Form:
`@name : Type`

Semantics:
- Declares a new constant `name` of domain `Type`.
- `name` must not be already defined.

### B) Definition Statements (Internal DAG Nodes)
Form:
`@name Verb arg1 arg2 ...`

Semantics:
- Defines a new variable `@name` as the result of applying `Verb` to the arguments.
- **No equal sign**.
- **No parentheses** around arguments.
- Arguments are space-separated.

### D) Block Definitions (Scopes)
Form:
`@name Verb args... begin`
  `... statements ...`
`end`

Semantics:
- Defines a scope (sub-DAG).
- The result of the block is typically the last statement in it, or defined by the Verb semantics (e.g., `lambda`).
- Used for `lambda`, `forall` (if defining a scope), or logical grouping.

## Expressions (Command Style)
All operators and predicates are strictly **prefix**, space-separated.

Core verbs:
- `and $a $b ...`
- `or $a $b ...`
- `not $a`
- `implies $ant $cons`
- `forall $varDomain $body`
- `lambda $arg begin ... end`

## Grammar (EBNF)
```
input        := stmt (NEWLINE stmt)* ;
stmt         := decl | def | block | assert ;

decl         := "@" IDENT ":" IDENT ;
def          := "@" IDENT IDENT args ;
assert       := IDENT args ;
block        := "@" IDENT IDENT args "begin" NEWLINE (stmt NEWLINE)* "end" ;

args         := (ws term)* ;
term         := "$" IDENT | "?" IDENT | IDENT ;
```

## Semantics Rules
1. **Space Separation**: Atoms are separated by whitespace.
2. **Explicit References**: `$x` refers to `@x`.
3. **No Sugar**: No parentheses, no commas, no `=`.
4. **Blocks**: Use `begin` and `end` for nesting scopes.

## Examples

### 1) Entity Graph
```
@ion:Person
@flu:Disease

# Defined edges
@f1 has_flu $ion $flu
@f2 has_fever $ion

# Assertion
implies $f1 $f2
```

### 2) Boolean Logic
```
@a:Bit
@b:Bit
# @g1 = a AND b
@g1 and $a $b
# @g2 = NOT g1
@g2 not $g1
# Assert g2
$g2
```

### 3) Lambda / Scope
```
@checker lambda $x begin
   @c1 gt $x 10
   @c2 lt $x 20
   and $c1 $c2
end
```



