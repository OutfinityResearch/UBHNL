# DS-008: DSL (Intermediate Language)

## Goal
Define a deterministic, typed DSL that sits between CNL and the solver/orchestrator stack:

`CNL (user input) → DSL (canonical text IR) → typed semantic IR → fragments/backends (incl. UBH)`

The DSL is both:
1) a stable intermediate representation for compilation/debugging/auditing, and
2) a power-user authoring format for theories and queries.

## Non-Negotiable Semantics (@ / $ / vocab)
This is the core rule set you requested; it drives the entire DSL design.

### 1) `@name` — declaration/definition target
- `@name` introduces (or selects) the **definition target** of the current statement.
- A statement may contain **at most one** `@...` token, and it must be the **first** term on the line.
- `@` is never used for references.

### 2) `$name` — variable reference
- `$name` references a symbol previously introduced by `@name` (or by a quantifier binder).
- Using `$name` when `name` is not in scope is a **load error**.

### 3) bare `name` — vocabulary lookup
- A bare identifier is looked up in the **vocabulary** (lexicon + any explicitly exported symbols).
- If the symbol is unknown, it is a **load error** (no silent creation).

This makes theory files reproducible and prevents “typo turns into new symbol”.

## Statement Forms
### A) Fact / Graph Statement (subject-first sugar)
Form:
`@s[:Type] P arg1 arg2 ... argN`

Desugars to a predicate application in the typed semantic IR:
`P(s, arg1, arg2, ..., argN)`

Where:
- `P` is a predicate symbol from the vocabulary (must be declared),
- `s` is the subject symbol introduced/selected by `@s`,
- each `argi` is a **term** (see below).

**Arity rule:** `arity(P) = 1 + N`

This “subject-first” shape is the DSL’s graph-friendly form: each line defines outgoing edges/properties of one node.

### B) Logical Statement
Form (core logic):
`forall $x in Domain: <expr>`
`exists $x in Domain: <expr>`
`<expr>`

Where `<expr>` is built from:
- `and`, `or`, `not`, `implies`,
- predicate calls: `P(t1, ..., tn)` (canonical form),
- parentheses.

### C) Declarations (exporting into vocabulary)
Form:
`@name:Type`

Semantics:
- declares `name` as an entity constant of domain `Type`,
- exports it into the vocabulary so it can be referenced later as a bare `name`.

## Top-Level Semantics (What a DSL File *Means*)
A DSL file is interpreted as a set of **asserted statements** that extend a theory.

Semantics by statement kind:
- `declStmt` (`@name:Type`):
  - updates the vocabulary (symbol table) by adding a typed constant.
  - does not add a logical constraint by itself.
- `factStmt` (`@s P ...`):
  - desugars to `P(s, ...)` and is asserted as true.
  - equivalent to adding the constraint `assert(P(s,...))`.
- `expr` / `quantified`:
  - the expression is asserted as true.
  - equivalent to adding the constraint `assert(<expr>)`.

“Assert” is a semantic action, not a surface keyword: the default file interpretation is that each statement is part of the theory.

## Terms
Terms appear in predicate arguments and graph statements.

### Term kinds
- `$x` : variable reference (must be in scope)
- `?x` : query hole (existential unknown; handled by the session/orchestrator)
- `name` : vocabulary symbol (constant or enum value; must exist)

Note: `@x` is not a term; it is only allowed as the *statement head*.

## Typing and Resolution
Typing is driven by the lexicon (DS-005) and enforced at load time.

### Predicate signatures
Each predicate has:
- `arity`,
- `args`: list of domain types.

Example:
`has_flu(Person, Disease)` → `arity=2`, `args=[Person, Disease]`.

### How subject typing works in graph statements
For `@s[:Type] P arg...`:
- `P` must exist in the vocabulary.
- The subject type must unify with `P.args[0]`.
  - If `@s:Type` is present, it must match `P.args[0]`.
  - If no explicit type is given, the type is inferred from usage and must remain consistent across all statements involving `s`.

### Bare identifiers must be known vocabulary
Any bare identifier used as a term must resolve to a known vocabulary constant/enum value.
Otherwise: **load error**.

## Queries and Holes (`?`)
Holes are only meaningful in queries (session layer). In the DSL they are syntactic markers.

Example:
`exists ?c in Cell: proteinP(?c)`

Meaning:
- find a witness assignment for `?c` such that the query is satisfiable in the current session theory.

The encoding/decoding of holes is specified in DS-009 and the fragment system (DS-010).

## Grammar (EBNF)
This is a reference grammar; implementations may use an equivalent parser.

```
input        := stmt (NEWLINE stmt)* ;
stmt         := declStmt | factStmt | quantified | expr ;

declStmt     := "@" IDENT ":" IDENT ;

factStmt     := "@" IDENT typeAnn? IDENT term* ;
typeAnn      := ":" IDENT ;

quantified   := ("forall" | "exists") binder ("," binder)* ":" expr ;
bindTerm     := ("$" IDENT) | ("?" IDENT) ;
binder       := bindTerm "in" IDENT ;

expr         := implies ;
implies      := orExpr (("implies" | "->") orExpr)* ;
orExpr       := andExpr (("or" | "|") andExpr)* ;
andExpr      := unary (("and" | "&") unary)* ;
unary        := ("not" | "!") unary
             | atom ;

atom         := "true" | "false"
             | predCall
             | "(" expr ")" ;

predCall     := IDENT "(" args? ")" ;
args         := term ("," term)* ;

term         := "$" IDENT
             | "?" IDENT
             | IDENT ;
```

**Rule enforced by grammar:** `@` only appears in `declStmt`/`factStmt` as the first token, so “two `@` on one line” is rejected.

Quantifier binder rules:
- `forall` binders MUST use `$x`.
- `exists` binders MAY use `$x` or `?x`:
  - `$x` behaves like a standard bound variable.
  - `?x` behaves like an existential variable that is additionally requested as an output witness.

## Load Errors (Must Reject)
- any statement containing more than one `@...` token
- `$x` used when `x` is not declared/in scope
- bare `name` used as a term but `name` is not in vocabulary
- unknown predicate `P`, arity mismatch, or type mismatch
- inconsistent inferred type for the same `@s` symbol across statements

## Examples
Assume vocabulary (lexicon) defines:
- domains: `Person`, `Disease`, `Cell`
- predicates:
  - `has_flu(Person, Disease)`
  - `has_fever(Person)`
  - `geneA(Cell)`
  - `proteinP(Cell)`

### 1) Declare entities (export to vocabulary)
```
@ion:Person
@flu:Disease
```
Now `ion` and `flu` can be referenced as bare identifiers.

### 2) Facts (graph statements)
```
@ion has_flu flu
@ion has_fever
```

### 3) Rule (logical statement)
```
forall $c in Cell: geneA($c) implies proteinP($c)
```

### 4) Correct variable reference (no second @)
```
@x:Person likes $y
```
Here `@x` is the subject being defined; `$y` must have been declared earlier (or be a bound variable).
