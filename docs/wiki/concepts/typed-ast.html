<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wiki: Typed semantic IR / AST</title>
    <link rel="stylesheet" href="../../site.css" />
      <script src="../../site-nav.js" defer></script>
  </head>
  <body>
    <header>
      <h1>Typed semantic IR / AST</h1>
      <p>The stable contract between the front-end (CNL/DSL) and compilation/solving.</p>
    </header>
    <main>
      <div class="card">
        <div class="draft">DRAFT: Wiki page.</div>

        <div class="nav">
          <a href="../index.html">Wiki</a>
          <a href="cnl.html">CNL</a>
          <a href="dsl.html">DSL</a>
          <a href="type-lowering.html">Type lowering</a>
          <a href="../../mdview.html?file=specs/DS/DS06-nl-pipeline.md">DS-006</a>
        </div>

        <h2>Definition</h2>
        <p>
          <strong>Typed semantic IR</strong> is the internal representation (data structures) that captures the logical meaning of the input,
          with attached <strong>types</strong> (finite domains or builtins), before lowering to fragments/backends.
        </p>

        <h2>Why it is necessary</h2>
        <ul>
          <li>Separates “parsing” from “solving”: the solver does not need to know about tokens/aliases.</li>
          <li>Enables <strong>fragment detection</strong> (DS-010): from the IR you can tell whether it is UBH/SAT, SMT(BV), TS, etc.</li>
          <li>It is the ideal point for normalizations (e.g., desugaring <code>if ... then ...</code>).</li>
        </ul>

        <h2>Core logic AST (minimal)</h2>
        <p>
          For deterministic CNL, there is a minimal node set:
        </p>
        <pre><code>ForAll(var, domain, body)
Exists(var, domain, body)
And/Or/Not/Implies
Pred(name, args[])
BoolLit(true/false)</code></pre>

        <h2>Connection to UBH</h2>
        <ul>
          <li>Core-logic expressions compile into UBH using the XOR/AND/CONST basis (<a href="ubh.html">UBH</a>).</li>
          <li>Quantifiers over finite domains either expand or become schemas (CEGAR) — see <a href="cegar.html">CEGAR</a>.</li>
        </ul>

        <h2>Consequences</h2>
        <ul>
          <li>Errors are classified: Parse/Resolve/Type, with file positions.</li>
          <li>Explanations can retain the link IR ↔ origins ↔ UBH constraints.</li>
        </ul>

        <h2>Relevant specs</h2>
        <ul>
          <li><a href="../../mdview.html?file=specs/DS/DS06-nl-pipeline.md">DS-006</a> (typed AST contract)</li>
          <li><a href="../../mdview.html?file=specs/DS/DS07-nl-ubh-compile.md">DS-007</a> (compilation to UBH)</li>
          <li><a href="../../mdview.html?file=specs/DS/DS10-fragments-goals.md">DS-010</a> (fragment detection)</li>
        </ul>
      </div>
    </main>
  </body>
</html>
