<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wiki: Constraints (assert)</title>
    <link rel="stylesheet" href="../../site.css" />
      <script src="../../site-nav.js" defer></script>
  </head>
  <body>
    <header>
      <h1>Constraints (assert)</h1>
      <p>How UBHNL represents “knowledge”: as Boolean assertions/equations.</p>
    </header>
    <main>
      <div class="card">
        <div class="draft">DRAFT: Wiki page.</div>

        <div class="nav">
          <a href="../index.html">Wiki</a>
          <a href="ubh.html">UBH</a>
          <a href="model-witness.html">Model</a>
          <a href="../../mdview.html?file=specs/UBH-SPEC.md">UBH-SPEC</a>
        </div>

        <h2>Definition</h2>
        <p>
          A <strong>constraint</strong> is a condition imposed on a wire (or between two wires) that must be true in any accepted model.
          The UBH kernel has a minimal set:
        </p>
        <div class="table-wrap">
          <table>
            <thead><tr><th>Constraint</th><th>Semantics</th><th>GF(2) form</th></tr></thead>
            <tbody>
              <tr><td><code>ASSERT1(w)</code></td><td><code>w = 1</code></td><td><code>w ⊕ 1 = 0</code></td></tr>
              <tr><td><code>ASSERT0(w)</code></td><td><code>w = 0</code></td><td><code>w = 0</code></td></tr>
              <tr><td><code>ASSERT_EQ(a,b)</code></td><td><code>a = b</code></td><td><code>a ⊕ b = 0</code></td></tr>
            </tbody>
          </table>
        </div>

        <h2>Theory</h2>
        <p>
          A <strong>theory</strong> (in the UBHNL sense) is a set of constraints plus node definitions (a circuit).
          “Learn” adds constraints; “query” temporarily adds additional constraints (e.g., <code>¬φ</code> for entailment).
        </p>

        <h2>Reasoning: from constraints to solve/prove</h2>
        <ul>
          <li><strong>Satisfy</strong>: does there exist a <a href="model-witness.html">model</a> that satisfies all constraints?</li>
          <li><strong>Prove</strong>: <code>T ⊨ φ</code> reduces to <code>solve(T ∧ ¬φ)</code>; we expect <code>UNSAT</code> (with a certificate) as evidence.</li>
          <li><strong>Refute</strong>: if <code>solve(T ∧ ¬φ)</code> returns <code>SAT</code>, the model is a counterexample.</li>
        </ul>

        <h2>Practical consequences</h2>
        <ul>
          <li>The kernel stays small: “knowledge” = assertions; everything else compiles to assertions.</li>
          <li>Verification is simple: for <code>SAT</code> validate the model; for <code>UNSAT</code> validate a <a href="certificates.html">certificate</a>.</li>
        </ul>

        <h2>Relevant specs</h2>
        <ul>
          <li><a href="../../mdview.html?file=specs/UBH-SPEC.md">UBH-SPEC</a> (constraint model + API)</li>
          <li><a href="../../mdview.html?file=specs/DS/DS02-solver-xor.md">DS-002</a> (how constraints reach CNF/XOR)</li>
          <li><a href="../../mdview.html?file=specs/DS/DS09-sessions-query-proof.md">DS-009</a> (origins + explainability)</li>
        </ul>
      </div>
    </main>
  </body>
</html>
