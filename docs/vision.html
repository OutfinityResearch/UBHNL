<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>UBHNL — Vision</title>
    <link rel="stylesheet" href="site.css" />
      <script src="site-nav.js" defer></script>
  </head>
  <body>
    <header>
      <h1>UBHNL — Vision and direction</h1>
      <p>A universal reasoning engine: minimal kernel + backends + certificates + explanations.</p>
    </header>
    <main>
      <div class="card">
        <div class="draft">DRAFT: narrative description. The target architecture is explicit; implementation is still in progress.</div>

        <div class="nav">
          <a href="index.html">Docs Index</a>
          <a href="architecture.html">Architecture</a>
          <a href="languages.html">Lexicon/CNL/DSL</a>
          <a href="session-api.html">Session API</a>
          <a href="reasoning.html">Reasoning</a>
          <a href="examples.html">Examples</a>
          <a href="wiki/index.html">Wiki</a>
          <a href="theory/index.html">Theory</a>
        </div>

        <h2>What we want to build</h2>
        <p>UBHNL is designed as a system that can:</p>
        <ul>
          <li><code>learn</code>: load theories (CNL/DSL files) and incrementally add knowledge in a session.</li>
          <li><code>query</code>: answer satisfiability, entailment (prove/refute), enumeration, counting, optimization, and synthesis goals.</li>
          <li><code>explain</code>: produce explanations in terms of the user vocabulary (file origins), not in terms of “wire ids”.</li>
          <li><code>audit</code>: accept only checkable results (witness/certificate), otherwise report <code>UNKNOWN</code> explicitly.</li>
        </ul>

        <h2>Design principles</h2>
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Principle</th><th>Consequence</th></tr>
            </thead>
            <tbody>
              <tr>
                <td>Small trusted core</td>
                <td>UBH kernel + checkers; backends can be complex and even “untrusted”, but results are accepted only with certificates.</td>
              </tr>
              <tr>
                <td>Determinism</td>
                <td>Deterministic parsing/typing; unknown symbol = load error; no “implicit new symbol”.</td>
              </tr>
              <tr>
                <td>Fragment-first</td>
                <td>“What problem do we have?” (fragment) is separated from “how do we solve it?” (backend/tactic).</td>
              </tr>
              <tr>
                <td>UBH as an anchor</td>
                <td>UBH is the bit-level lingua franca for many encodings and for checking, but not everything should be compiled to UBH.</td>
              </tr>
              <tr>
                <td>Memory: files + session</td>
                <td>Theory files (DSL/CNL) are long-term; the session is short-term and caches artifacts; it can be reconstructed from files.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h2>System diagram</h2>
        <pre><code>          (long-term)                (short-term)
        theory files ───────┐        session delta (learn)
         (*.dsl/*.cnl)      │                 │
                 │          │                 ▼
                 └──── parse/type (strict vocab + origins)
                              │
                              ▼
                      typed semantic IR
                              │
                              ▼
          fragment detection + goal kind normalization
                              │
                              ▼
                     orchestrator builds plan DAG
                              │
          ┌───────────────────┼────────────────────┐
          ▼                   ▼                    ▼
      SAT/UBH backend      SMT backend          MC/IC3/…
     (DRAT/LRAT)         (proof/model)      (invariant/trace)
          │                   │                    │
          └─────────────── certificate checkers ───┘
                              │
                              ▼
                    result + explain (origins)</code></pre>

        <h2>Why UBH (in one sentence)</h2>
        <p>
          UBH is a minimal representation of Boolean constraints as a circuit (XOR/AND/CONST) with a GF(2) interpretation, enabling structural
          compression (hash-consing) and efficient reasoning (SAT + native XOR equations).
        </p>

        <h2>What “universal” means here</h2>
        <ul>
          <li><strong>universal as a substrate</strong>: many finite theories can be reduced to bits (BV, finite domains, bounded TS) and end up in UBH/SAT;</li>
          <li><strong>universal as orchestration</strong>: when compilation is not efficient (MIP/SDP/NRA), keep a native backend and verify its certificates;</li>
          <li><strong>universal as auditability</strong>: “hard” results are accepted only with checkable certificates.</li>
        </ul>

        <h2>Links (normative specs)</h2>
        <ul>
          <li><a href="mdview.html?file=specs/src/system-spec.md">System Spec</a></li>
          <li><a href="mdview.html?file=specs/UBH-SPEC.md">UBH Kernel Spec</a></li>
          <li><a href="mdview.html?file=specs/DS/DS10-fragments-goals.md">DS-010 Fragments</a></li>
          <li><a href="mdview.html?file=specs/DS/DS11-backends-certificates.md">DS-011 Backends/Certificates</a></li>
          <li><a href="mdview.html?file=specs/DS/DS12-orchestrator-planner.md">DS-012 Orchestrator</a></li>
        </ul>
      </div>
    </main>
  </body>
</html>
